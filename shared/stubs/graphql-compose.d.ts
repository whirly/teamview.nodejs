/** Declaration file generated by dts-gen, and then edited by hand following the needs */

// tslint:disable:member-access
// tslint:disable:max-line-length
// tslint:disable:max-classes-per-file
// tslint:disable:interface-name

declare module 'graphql-compose' {
    import {
        GraphQLObjectType,
        GraphQLObjectTypeConfig,
        GraphQLOutputType,
        GraphQLFieldConfigArgumentMap,
        GraphQLResolveInfo
    } from 'graphql';

    export type TypeDefinitionString = string;
    export type TypeWrappedString = string; // eg. Int, Int!, [Int]
    export type TypeNameString = string; // eg. Int, Float

    export class ComposeStorage {
        constructor();

        add(typeComposer: any): void;

        buildRelations(typeComposer: any, createdRelations: any): void;

        buildSchema(): any;

        clear(): void;

        get(typeName: any): any;

        has(typeName: any): any;

        removeEmptyTypes(typeComposer: any, ...args: any[]): void;

        resolver(typeName: any, resolverName: any): any;

        resolvers(typeName: any): any;

        rootMutation(): any;

        rootQuery(): any;

    }

    export interface IGraphQlFields {

    }

    export class InputTypeComposer {
        static create(opts: TypeNameString | TypeDefinitionString | GraphQLObjectTypeConfig<any, any> | GraphQLObjectType): TypeComposer;

        constructor(gqType: any);

        addField(fieldName: any, fieldConfig: any): void;

        addFields(newFields: any): void;

        clone(newTypeName: any): any;

        get(path: any): any;

        getByPath(path: any): any;

        getDescription(): any;

        getField(fieldName: any): any;

        getFieldNames(): any;

        getFieldType(fieldName: any): any;

        getFields(): any;

        getType(): any;

        getTypeAsRequired(): any;

        getTypeName(): any;

        hasField(fieldName: any): any;

        isFieldRequired(fieldName: any): any;

        isRequired(fieldName: any): any;

        makeFieldsOptional(fieldNameOrArray: any): void;

        makeFieldsRequired(fieldNameOrArray: any): void;

        makeOptional(fieldNameOrArray: any): void;

        makeRequired(fieldNameOrArray: any): void;

        removeField(fieldNameOrArray: any): any;

        setDescription(description: any): void;

        setField(fieldName: any, fieldConfig: any): void;

        setFields(fields: any): any;

        setTypeName(name: any): void;
    }

    export type Thunk<T> = (() => T) | T;
    export interface ObjectMap { [optName: string]: any; }
    export interface ProjectionType { [fieldName: string]: true | ProjectionType; }
    export interface ProjectionMapType { [relationfieldName: string]: ProjectionType; }

    export interface ResolveParams<TSource, TContext> {
        source: TSource;
        args: { [argName: string]: any };
        context: TContext;
        info: GraphQLResolveInfo;
        projection: ProjectionType;
        [opt: string]: any;
    }

    export type ResolverMWMethodKeys = 'args' | 'resolve' | 'type';
    export type ResolverKinds = 'query' | 'mutation' | 'subscription';

    export type ResolverMWArgsFn = (args: GraphQLFieldConfigArgumentMap) => GraphQLFieldConfigArgumentMap;
    export type ResolverMWArgs = (next: ResolverMWArgsFn) => ResolverMWArgsFn;

    export type ResolverMWResolveFn<TSource, TContext> = (resolveParams: ResolveParams<TSource, TContext>) => Promise<any>;
    export type ResolverMWResolve<TSource, TContext> = (next: ResolverMWResolveFn<TSource, TContext>) => ResolverMWResolveFn<TSource, TContext>;

    export type ResolverMWOutputTypeFn = (outputType: GraphQLOutputType) => GraphQLOutputType;
    export type ResolverMWOutputType = (next: ResolverMWOutputTypeFn) => ResolverMWOutputTypeFn;

    export interface ResolverOpts<TSource, TContext> {
        type?: GraphQLOutputType;
        resolve?: ResolverMWResolveFn<TSource, TContext>;
        args?: GraphQLFieldConfigArgumentMap;
        name?: string;
        kind?: ResolverKinds;
        description?: string;
        parent?: Resolver<TSource, TContext>;
    }

    export class Resolver<TSource, TContext> {
        constructor(opts: ResolverOpts<TSource, TContext>);

        addArgs(newArgs: any): void;

        addFilterArg(opts: any): any;

        addSortArg(opts: any): any;

        clone(...args: any[]): any;

        cloneArg(argName: any, newTypeName: any): void;

        get(path: any): any;

        getArg(argName: any): any;

        getArgType(argName: any): any;

        getArgs(): any;

        getDescription(): any;

        getFieldConfig(...args: any[]): any;

        getKind(): any;

        getNestedName(): any;

        getOutputType(): any;

        getResolve(): any;

        getType(): any;

        getTypeComposer(): any;

        hasArg(argName: any): any;

        isRequired(argName: any): any;

        makeOptional(argNameOrArray: any): void;

        makeRequired(argNameOrArray: any): void;

        removeArg(argName: any): void;

        resolve(resolveParams: any): any;

        setArg(argName: any, argConfig: any): void;

        setArgs(args: any): void;

        setDescription(description: any): void;

        setKind(kind: any): void;

        setOutputType(gqType: any): void;

        setResolve(resolve: any): void;

        setType(gqType: any): void;

        toString(...args: any[]): any;

        wrap(cb: any, ...args: any[]): any;

        wrapArgs(cb: any, ...args: any[]): any;

        wrapCloneArg(argName: any, newTypeName: any): any;

        wrapOutputType(cb: any, ...args: any[]): any;

        // tslint:disable-next-line:ban-types
        wrapResolve(cb: (next: Function) => (resolveParams: any) => void, ...args: any[]): any;

        wrapType(cb: any, ...args: any[]): any;

    }

    export class TypeComposer {
        static create(opts: TypeNameString | TypeDefinitionString | GraphQLObjectTypeConfig<any, any> | GraphQLObjectType): TypeComposer;

        constructor(gqType: any);

        addField(fieldName: any, fieldConfig: any): void;

        addFields(newFields: any): void;

        addInterface(interfaceObj: any): void;

        addProjectionMapper(fieldName: any, sourceProjection: any): void;

        addRelation(fieldName: any, relationFn: any): any;

        addRelationWithResolver(fieldName: any, resolver: any, opts: any): any;

        addResolver(resolver: any): void;

        buildRelation(fieldName: any): void;

        buildRelations(): void;

        clone(newTypeName: any): any;

        extendField(name: any, parialFieldConfig: any): any;

        get(path: any): any;

        getByPath(path: any): any;

        getDescription(): any;

        getField(fieldName: any): any;

        getFieldArg(fieldName: any, argName: any): any;

        getFieldArgs(fieldName: any): any;

        getFieldNames(): any;

        getFieldType(fieldName: any): any;

        getFieldTC(fieldName: any): any;

        getFields(): any;

        getInputType(): any;

        getInputTypeComposer(): any;

        getInterfaces(): any;

        getProjectionMapper(): any;

        getRecordId(source: any, args: any, context: any): any;

        getRecordIdFn(): any;

        getRelations(): any;

        getResolver(name: any): any;

        getResolvers(): any;

        getType(): any;

        getTypeName(): any;

        getTypePlural(): any;

        hasField(fieldName: any): any;

        hasInputTypeComposer(): any;

        hasInterface(interfaceObj: any): any;

        hasRecordIdFn(): any;

        hasResolver(name: any): any;

        removeField(fieldNameOrArray: any): any;

        removeInterface(interfaceObj: any): void;

        removeResolver(resolverName: any): void;

        setDescription(description: any): void;

        setField(fieldName: any, fieldConfig: any): void;

        setFields(fields: any): any;

        setInterfaces(interfaces: any): void;

        setRecordIdFn(fn: any): void;

        setResolver(name: any, resolver: any): void;

        setTypeName(name: any): void;
    }

    export const convertInputObjectFieldOpts: any;

    export function camelCase(str: any): any;

    export function clearName(str: any): any;

    export function deepmerge(target: any, src: any): any;

    export function getFlatProjectionFromAST(context: any, fieldNodes: any): any;

    export function getPluralName(name: any): any;

    export function getProjectionFromAST(context: any, fieldNode: any): any;

    export function isFunction(value: any): any;

    export function isObject(value: any): any;

    export function isString(value: any): any;

    export function omit(obj: any, keys: any): any;

    export function only(obj: any, keys: any): any;

    export function resolveMaybeThunk(thingOrThunk: any): any;

    export function toDottedObject(obj: any, ...args: any[]): any;

    export function toInputObjectType(typeComposer: any, ...args: any[]): any;

    export function upperFirst(str: any): any;

    export namespace GQC {
        const types: {
        };

        function add(typeComposer: any): void;

        function buildRelations(typeComposer: any, createdRelations: any): void;

        function buildSchema(): any;

        function clear(): void;

        function get(typeName: any): any;

        function has(typeName: any): any;

        function removeEmptyTypes(typeComposer: any, ...args: any[]): void;

        function resolver(typeName: any, resolverName: any): any;

        function resolvers(typeName: any): any;

        function rootMutation(): any;

        function rootQuery(): any;

    }

    export namespace GraphQLBuffer {
        const description: any;

        const name: string;

        function inspect(): any;

        function parseLiteral(valueNode: any): any;

        function parseValue(value: any): any;

        function serialize(value: any): any;

        function toJSON(): any;

        function toString(): any;

    }

    export namespace GraphQLDate {
        const description: any;

        const name: string;

        function inspect(): any;

        function parseLiteral(valueNode: any): any;

        function parseValue(value: any): any;

        function serialize(value: any): any;

        function toJSON(): any;

        function toString(): any;

    }

    export namespace GraphQLGeneric {
        const description: any;

        const name: string;

        function inspect(): any;

        function parseLiteral(valueNode: any): any;

        function parseValue(value: any): any;

        function serialize(value: any): any;

        function toJSON(): any;

        function toString(): any;

    }

    export namespace GraphQLJSON {
        const description: string;

        const name: string;

        function inspect(): any;

        function parseLiteral(valueNode: any): any;

        function parseValue(value: any): any;

        function serialize(value: any): any;

        function toJSON(): any;

        function toString(): any;

    }
}
